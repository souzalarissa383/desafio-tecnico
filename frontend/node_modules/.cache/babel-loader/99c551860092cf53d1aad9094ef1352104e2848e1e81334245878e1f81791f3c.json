{"ast":null,"code":"// recommendation.service.js\n\n/**\n * Calcula o score de matching entre um produto e as preferências/features do usuário\n */\nconst calculateProductScore = (product, selectedPreferences, selectedFeatures) => {\n  if (selectedPreferences.length === 0 && selectedFeatures.length === 0) {\n    return 1;\n  }\n  let preferenceScore = 0;\n  let featureScore = 0;\n\n  // Calcula score baseado nas preferências\n  if (selectedPreferences.length > 0 && product.preferences) {\n    const matchingPreferences = selectedPreferences.filter(pref => product.preferences.includes(pref)).length;\n    preferenceScore = matchingPreferences / selectedPreferences.length;\n  }\n  if (selectedFeatures.length > 0 && product.features) {\n    const matchingFeatures = selectedFeatures.filter(feature => product.features.includes(feature)).length;\n    featureScore = matchingFeatures / selectedFeatures.length;\n  }\n  const totalSelections = selectedPreferences.length + selectedFeatures.length;\n  if (totalSelections === 0) return 1;\n  return (preferenceScore * selectedPreferences.length + featureScore * selectedFeatures.length) / totalSelections;\n};\nconst filterAndSortProducts = (products, selectedPreferences, selectedFeatures) => {\n  return products.map(product => ({\n    ...product,\n    score: calculateProductScore(product, selectedPreferences, selectedFeatures)\n  })).filter(product => product.score > 0).sort((a, b) => {\n    if (b.score !== a.score) {\n      return b.score - a.score;\n    }\n    return b.name.localeCompare(a.name);\n  });\n};\n\n/**\n * Lógica principal de recomendação de produtos\n */\nconst getRecommendations = (formData = {\n  selectedPreferences: [],\n  selectedFeatures: [],\n  selectedRecommendationType: 'SingleProduct'\n}, products = []) => {\n  const {\n    selectedPreferences = [],\n    selectedFeatures = [],\n    selectedRecommendationType = 'SingleProduct'\n  } = formData;\n  if (!products.length) {\n    return [];\n  }\n  const scoredProducts = filterAndSortProducts(products, selectedPreferences, selectedFeatures);\n\n  // Suporta tanto 'SingleProduct'/'MultipleProducts' quanto 'single'/'multiple'\n  const isSingleMode = selectedRecommendationType === 'SingleProduct' || selectedRecommendationType === 'single';\n  if (isSingleMode) {\n    if (scoredProducts.length === 0) return [];\n    const maxScore = scoredProducts[0].score;\n    const bestProducts = scoredProducts.filter(p => p.score === maxScore);\n\n    // Retorna o ÚLTIMO produto da lista ordenada em caso de empate\n    return [bestProducts[bestProducts.length - 1]];\n  }\n  return scoredProducts;\n};\n\n// Corrigindo a exportação para evitar warning do ESLint\nconst recommendationService = {\n  getRecommendations,\n  calculateProductScore // Exportando para testes\n};\nexport default recommendationService;","map":{"version":3,"names":["calculateProductScore","product","selectedPreferences","selectedFeatures","length","preferenceScore","featureScore","preferences","matchingPreferences","filter","pref","includes","features","matchingFeatures","feature","totalSelections","filterAndSortProducts","products","map","score","sort","a","b","name","localeCompare","getRecommendations","formData","selectedRecommendationType","scoredProducts","isSingleMode","maxScore","bestProducts","p","recommendationService"],"sources":["C:/Users/laris/OneDrive/Documentos/tech-interview-frontend-entry-level-main/monorepo/frontend/src/services/recommendation.service.js"],"sourcesContent":["// recommendation.service.js\n\n/**\n * Calcula o score de matching entre um produto e as preferências/features do usuário\n */\nconst calculateProductScore = (product, selectedPreferences, selectedFeatures) => {\n  if (selectedPreferences.length === 0 && selectedFeatures.length === 0) {\n    return 1;\n  }\n\n  let preferenceScore = 0;\n  let featureScore = 0;\n\n  // Calcula score baseado nas preferências\n  if (selectedPreferences.length > 0 && product.preferences) {\n    const matchingPreferences = selectedPreferences.filter(pref => \n      product.preferences.includes(pref)\n    ).length;\n    preferenceScore = matchingPreferences / selectedPreferences.length;\n  }\n\n  \n  if (selectedFeatures.length > 0 && product.features) {\n    const matchingFeatures = selectedFeatures.filter(feature =>\n      product.features.includes(feature)\n    ).length;\n    featureScore = matchingFeatures / selectedFeatures.length;\n  }\n\n  \n  const totalSelections = selectedPreferences.length + selectedFeatures.length;\n  if (totalSelections === 0) return 1;\n  \n  return ((preferenceScore * selectedPreferences.length) + (featureScore * selectedFeatures.length)) / totalSelections;\n};\n\n\nconst filterAndSortProducts = (products, selectedPreferences, selectedFeatures) => {\n  return products\n    .map(product => ({\n      ...product,\n      score: calculateProductScore(product, selectedPreferences, selectedFeatures)\n    }))\n    .filter(product => product.score > 0)\n    .sort((a, b) => {\n     \n      if (b.score !== a.score) {\n        return b.score - a.score;\n      }\n      \n      return b.name.localeCompare(a.name);\n    });\n};\n\n/**\n * Lógica principal de recomendação de produtos\n */\nconst getRecommendations = (\n  formData = { selectedPreferences: [], selectedFeatures: [], selectedRecommendationType: 'SingleProduct' },\n  products = []\n) => {\n  const { \n    selectedPreferences = [], \n    selectedFeatures = [], \n    selectedRecommendationType = 'SingleProduct' \n  } = formData;\n\n  if (!products.length) {\n    return [];\n  }\n\n  const scoredProducts = filterAndSortProducts(products, selectedPreferences, selectedFeatures);\n\n  // Suporta tanto 'SingleProduct'/'MultipleProducts' quanto 'single'/'multiple'\n  const isSingleMode = selectedRecommendationType === 'SingleProduct' || selectedRecommendationType === 'single';\n\n  if (isSingleMode) {\n    if (scoredProducts.length === 0) return [];\n    \n    const maxScore = scoredProducts[0].score;\n    const bestProducts = scoredProducts.filter(p => p.score === maxScore);\n    \n    // Retorna o ÚLTIMO produto da lista ordenada em caso de empate\n    return [bestProducts[bestProducts.length - 1]];\n  }\n\n  return scoredProducts;\n};\n\n// Corrigindo a exportação para evitar warning do ESLint\nconst recommendationService = {\n  getRecommendations,\n  calculateProductScore // Exportando para testes\n};\n\nexport default recommendationService;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}